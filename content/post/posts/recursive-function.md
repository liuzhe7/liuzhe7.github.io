---
title: "尾递归优化"
date: "2023-06-26"
tags:
  - c
  - algorithm
---

递归是指函数会调用自己的情况，函数调用到返回到过程中都可能会在栈和寄存器中创建销毁数据，并且栈内存也存在被耗尽的风险，尾递归优化通过减少这种创建与销毁来来解决这两个问题。<!--more-->

```c
int factorial(int num) {
  if (num == 1 || num == 0)
    return 1;
  return num * factorial(num - 1);
}
```

这段代码是求 num 的阶乘，可以抽象为 f(x) = x \* f(x-1),f 是阶乘函数，终止条件是 num==1 或者 num==0。每一次函数调用都依赖下一次函数调用的结果，因此需要在栈中保存每一层函数调用中的 num，这就有可能会导致文章开头的那两个问题。

如果用尾递归优化，该函数可以这样实现

```c
int factorial(int n, int acc) {
  if (n == 0) {
    return acc;
  } else {
    return factorial(n-1, acc * n)
  }
}
```

这段代码抽象为递归表达式是 f(x,y) = f(x-1, xy), f 可以理解为求 x 的阶乘，并把结果保存在 y 中，终止条件是 x==0。
这个之所以能优化的关键点是 **递归调用语句是函数的结束语句。** 第一种方式递归调用后还要乘一个 num。**上一个函数的返回值就是当前函数的返回值，编译器会把函数调用指令更改为跳转指令，相当于多层函数调用会变成一个长函数。**

这样一来，如果 num 是个很大的数字，就能大幅度减少栈的创建和销毁次数。
