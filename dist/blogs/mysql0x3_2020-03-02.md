---
draft: false
title: 'mysql.0x3--schema、数据类型优化'
date: '2020-03-02'
tags:
  - mysql
  - database
---

表该怎么设计？该使用什么样的数据类型？这是开发人员最需要掌握的数据库知识之一了。本文将介绍这方面的设计原则和使用技巧。

# 数据类型选取原则

mysql支持多种数据类型，不管存储哪种类型，以下三个原则都是要遵守的。

- 更小的通常更好
  一般情况下，应该尽量使用可以正确存储数据的最小数据类型，它们占用更少的磁盘、内存、CPU缓存。
- 简单就好
  能用整形就不用字符串，cpu处理整形更容易。用date,time,datetime存储时间而不是字符串。**比如用32位无符号整形存储ip地址。**
- 尽量避免NULL
  通常情况下最好指定列为NOT NULL，NULL会占用更多的存储空间，排序比较相对复杂。

# 数字

数字包括整数和实数。

## 整数

存储整数可以用TINYINT、SAMALLINT、MEDIUMINT、INT、BIGINT分别占用8、16、24、32、64位存储空间。可选UNSIGNED属性表示没有复数。**关于计算机是怎么存储数字的，可以看本站的第一篇文章，深入理解计算机系统-数据实验。**

## 实数

实数是带有小数部分的数字。

folat和double使用的标准的浮点运算进行近似计算。**DECIMAL用于存储精确的小数。**

**DECIMAL (M, D) 表示数字一共M位，小数有D位，占用M+2个字节，DECIMAL是一个比较消耗空间的类型**

```sql
amount DECIMAL(6,2);
```

在此示例中，amount列最多可以存储6位数字，小数位数为2位; 因此，amount列的范围是从-9999.99到9999.99。

可以用BIGINT代替DECIMAL节约存储空间。

**假设财务数据要精确到万分之一，可以把所有金额乘以100万存储到BIGINT里。**

# 字符串

mysql支持多种字符串类型。

## VARCHAR和CHAR

VARCHAR存储可变长的字符串，CHAR存储定长的字符串。VARCHAR往往更节约空间，因为他只占用必要的空间，VARCHAR需要额外的1-2字节存储长度。

**由于VARCHAR变长的特性UPDATE时可能会比原来变得更长，在InnoDB里可能会导致页分裂。**所以以下情况使用VARCHAR比较好。

- 字符串最大长度比平均长度大很多
- 很少有更新操作
- 使用了UTF-8字符集

相反的CHAR就适合存储以下值

- 所有字符串长度都接近，比如定长的MD5
- 频繁更新的值
- 非常短的值，比如CHAR(1)只占1字节，VARCHAR(1)因为需要一字节记录长度所以会占2字节，长度翻倍了

**char会自动删除掉末尾的空格，末尾有空格的字符串不要使用这个类型。**

## BLOB和TEXT

BLOB和TEXT都是为了存储很大的数据而设计的字符串类型，分别采用二进制和字符方式存储，这也是这两种类型的唯一区别。

**排序的时候VARCHAR会取整个字符串进行排序，而TEXT只拍前面一小部分。因此如果你内存充足就使用varchar，如果不足可以使用text**

## 枚举

**使用枚举代替字符串可以提升性能、节约存储空间，因为mysql在底层存储的是数字，把数字到字符串的映射关系保存在.frm文件中。**

```sql
CREATE TABLE enum_test(e ENUM('fish','apple','dog') NOT NULL);
```

而且枚举排序是依照存储的整数，而不是字符串。

## 日期和时间

对于时间类型，我们只需要弄清楚什么时候用DATETIME什么时候用TIMESTAMP就够了。

- DATETIME
  这个类型能保存1001年到9999年任意时刻到值，精度为秒。如“2008-01-16 22:37:08”。

- TIMESTAMP
  它保存了1970年1月1日午夜以来的秒数。它只占4个字节比DATETIME小的多。只能表示1970到2038年。它和你系统的时区有关。

所以**如果1970-2038的时间范围就够用了，那就使用TIMESTAMP。**

## 位

- BIT
  MySQL提供了允许您存储位值的BIT类型。BIT(m)可以存储多达m位的值，m的范围在1到64之间，BIT会被MYSQL解释为字符串，是很难阅读的，因此建议你不要使用这个类型。
- SET
  SET和ENUM类型非常相似，它适合于只能在一组固定值中选零个或多个的场景，底层也是用数字存储，占用空间少。缺点是ALTER修改时成本较高。

## 标志列

一般来说更有可能通过标志列与其他值进行比较，或者通过标志列寻找其他列，**对于标志列最好使用整形，它更快，并且也可以使用AUTO_INCREMENT变得非常紧凑。**

# 范式

一般地，在进行数据库设计时，应遵循三大原则，也就是我们通常说的三大范式。

- 第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。

- 第二范式（2NF）数据库表中的每一列都只和主键相关。

- 第三范式（3NF）数据表中的每一列数据都和主键直接相关，而不能间接相关。

**符合范式的表通常比较小，更新速度更快。但是没有冗余也往往意味着需要更多的关联查询，所以并不一定要严格的遵守范式。**

# 缓存表与汇总表

我们用缓存表储存那些能够简单的从schema其他表获取但是每次获取速度比较慢的表。汇总表保存聚合数据。

汇总表一个常用的技巧是统计行数，**行数非常多的表统计总行数时，在innoDB中count()函数要扫描所有行，效率比较低，我们可以单独的用一张表来保存行数。但是在统计表中我们不应该只用一行来保存总行数，这样的话会变成了串行的更新。根据并发程度不同，用多行保存，多行的和作为总数。**

# 总结

- 选择数据类型要遵循以下原则
  - 一般情况下，应该尽量使用可以正确存储数据的最小数据类型，它们占用更少的磁盘、内存、CPU缓存。
  - 能用整形就不用字符串，cpu处理整形更容易。用date,time,datetime存储时间而不是字符串。**比如用32位无符号整形存储ip地址。**
  - 通常情况下最好指定列为NOT NULL，NULL会占用更多的存储空间，排序比较相对复杂。
- DECIMAL (M, D) 表示数字一共M位，小数有D位，占用M+2个字节，DECIMAL是一个比较消耗空间的类型。
- 可以用BIGINT代替DECIMAL，假设财务数据要精确到万分之一，可以把所有金额乘以100万存储到BIGINT里。
- 由于VARCHAR变长的特性UPDATE时可能会比原来变得更长，在InnoDB里可能会导致页分裂。
- char会自动删除掉末尾的空格，末尾有空格的字符串不要使用这个类型。
- 排序的时候VARCHAR会取整个字符串进行排序，而TEXT只拍前面一小部分。因此如果你内存充足就使用varchar，如果不足可以使用text。
- 使用枚举代替字符串可以提升性能、节约存储空间，因为mysql在底层存储的是数字，把数字到字符串的映射关系保存在.frm文件中。
- 如果1970-2038的时间范围就够用了，那就使用TIMESTAMP。
- 对于标志列最好使用整形，它更快，并且也可以使用AUTO_INCREMENT变得非常紧凑。
- 行数非常多的表统计总行数时，在innoDB中count()函数要扫描所有行，效率比较低，我们可以单独的用一张表来保存行数。但是在统计表中我们不应该只用一行来保存总行数，这样的话会变成了串行的更新。根据并发程度不同，用多行保存，多行的和作为总数。
